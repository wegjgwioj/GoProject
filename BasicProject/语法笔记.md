# Go 特性：
  - 静态类型语言： 在编译时进行类型检查，减少运行时错误。
  - 并发支持： 内置 goroutine 和 channel，简化并发编程。--语言级别支持
  - 垃圾回收： 自动内存管理，减少内存泄漏   
  - 丰富的标准库： 提供网络、文件操作、加密等多种功能。
  - 内嵌C支持： 通过 cgo 调用 C 代码，扩展功能。

代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等

缺点：
  - 泛型支持较晚： Go 1.18 版本才引入泛型，生态系统中泛型使用还不广泛。
  - 错误处理繁琐： 采用显式错误返回，代码中大量的错误检查语句。
  - 第三方库质量参差不齐： 由于生态系统相对较新，部分库缺乏成熟度。
  - GUI 支持有限： 原生支持 GUI 的库较少，主要用于后端开发。


  # 特殊性质：

  ## iota            
  ''' 
  const (
      [变量1] [运算符] iota // A [运算符] 0
      [变量2]               // B [运算符] 1
      [变量3]               // C [运算符] 2
    )
    - iota 是 Go 语言中的一个预定义标识符，用于在常量声明中生成一组相关的常量值。
    - iota 在每个 const 声明块中从 0 开始递增，每遇到一个新的 const 声明块，iota 会重新计数。
    - 主要用于简化枚举类型的定义，使代码更简洁易读。
    - 示例：
      ```go
      const (
          A = iota // A == 0
          B        // B == 1
          C        // C == 2
      )

      const (
          X << iota  // X == 0 (1 << 0)
          Y            // Y == 1 (1 << 1)
          Z            // Z == 2 (1 << 2)    
      )
      ```
      实际使用中，iota 可以帮助我们避免手动为每个常量赋值，减少出错的可能性。   

## 函数
  ### 引用传递 * 和 值传递 
  - Go 语言中的函数参数传递方式主要有两种：值传递和引用传递。
  - 值传递： 当函数参数是基本数据类型（如 int、float、bool）或结构体时，Go 语言采用值传递方式。函数接收的是参数的副本，对参数的修改不会影响原始变量。
  - 引用传递： 当函数参数是指针类型时，Go 语言采用引用传递方式。函数接收的是参数的地址，通过指针可以直接修改原始变量的值。
  ### 执行顺序
  - Go 语言中的函数调用是按照调用顺序执行的，函数调用时
会将控制权转移到被调用的函数，直到该函数执行完毕后才会返回到调用点继续执行。
  - 函数调用时，参数会按照从左到右的顺序进行求值。 
  ### 首字母大写
  - 在 Go 语言中，标识符（如变量名、函数名、类型名等）的首字母大小写决定了其可见性。
  - 首字母大写： 如果标识符的首字母是大写的，那么该标识符是导出的（exported），可以在包外部访问。
  - 首字母小写： 如果标识符的首字母是小写的，那么该标识符是未导出的（unexported），只能在包内部访问。

  ## defer 语句

#### 1. 核心机制：执行顺序与时机

* **数据结构**：`defer` 内部由**栈（Stack）**管理，遵循 **LIFO (后进先出)** 原则。最后注册的 `defer` 最先执行。
* **底层时机 (的关键)**：
`defer` 并非在 `return` 语句之后执行，而是夹在 `return` 的底层指令中间。`return` 语句被编译器拆解为三步：
1. **赋值**：将返回值写入栈帧中的返回值内存地址。
2. **执行 Defer**：运行注册的延迟函数（此时有机会修改**具名返回值**）。
3. **指令 RET**：CPU 执行 `RET` 指令，携带返回值退出函数。

#### 2. 两个高频面试坑（必考）

**考点 A：参数预计算 (Evaluation Moment)**

* **规则**：`defer` 在**声明那一行**时，会立即计算函数参数的值，并将其“压栈”固定下来（值拷贝）。
* **例外**：如果 `defer` 后面跟的是**闭包（Closure）**且内部使用了外部变量（未通过参数传递），则在**执行时**才会去引用外部变量的当前值。

> **面试话术**：“Defer 的参数是注册时拷贝，闭包内部的变量是执行时引用。”

**考点 B：具名返回值 vs 匿名返回值**

* **匿名返回值** (`func f() int`)：
`return x` 会把 `x` 的值**拷贝**给返回值空间。`defer` 内部修改 `x` 只是修改了局部变量，无法影响已经拷贝好的返回值，**修改无效**。
* **具名返回值** (`func f() (r int)`)：
返回值变量 `r` 和函数内的局部变量是**同一块内存**。`defer` 修改 `r` 就是直接修改最终结果，**修改有效**。

#### 3. 与 Panic/Recover 的交互

* **执行保证**：即使函数发生 `panic`，已经注册的 `defer` 依然会执行（这是 Go 资源安全的核心保障）。
* **捕获方式**：`recover()` 必须在 `defer` 函数内部直接调用才有效。
* **流程**：`panic` -> 停止当前逻辑 -> 栈回溯 (Stack Unwinding) -> 逐个执行 `defer` -> 遇到 `recover` -> 停止回溯，恢复控制流。

#### 4. 性能演进 (加分项)

* **早期版本**：`defer` 涉及堆内存分配（`_defer` 结构体），在循环中使用会有较大性能开销。
* **Go 1.13/1.14+ 优化**：引入了 **Open-coded defer**（开放编码）。
* 编译器将 `defer` 调用直接**内联**插入到函数的各个返回点（RET 之前）。
* 绝大多数场景下，`defer` 变成了简单的函数调用，**零堆分配**，性能开销几乎可以忽略不计。



#### 5. 常见应用场景

* **资源释放**：互斥锁（`Mutex.Unlock`）、文件句柄（`File.Close`）、网络连接。
* **Panic 捕获**：在 goroutine 入口处使用 `defer + recover` 防止单点崩溃导致整个进程退出。
* **耗时统计**：`defer` 记录函数结束时间减去开始时间。

---

### 面试速记口诀（心法）

> **“Defer 是 Go 语言用于延迟调用的机制，遵循后进先出原则。它在 `return` 赋值之后、`RET` 指令之前执行，因此可以修改具名返回值，并且是唯一可以捕获 Panic 的机制。从 1.14 版本后，由于内联优化，其性能损耗已极低。”**
   
## slice “动态数组”和 map

## 面向对象特征
  - 结构体（struct）： Go 语言通过结构体实现数据的封装，类似于面向对象中的类。
  - 方法（method）： 可以为结构体定义方法，实现行为的封装。
  - 接口（interface）： 定义一组方法签名，实现多态和抽象。
  - 嵌入（embedding）： 通过嵌入结构体实现代码复用和组合。
 ### 方法：
  - 方法是与特定类型关联的函数，可以通过接收者（receiver）来访问该类型的字段和方法。
  - 方法的定义格式为：`func (receiver Type) MethodName(params) returnType { }`
  - 接收者可以是值类型或指针类型，选择哪种类型取决于是否需要修改接收者的值。
  - 方法可以实现接口，从而实现多态行为。
  #### 方法表达式：
  - 方法表达式允许将方法作为函数值使用，格式为：`Type.MethodName`
  - 方法表达式的第一个参数是接收者类型的实例，后续参数与方法定义中的参数一致。
  - 通过方法表达式，可以将方法赋值给变量或传递给其他函数。
  #### 方法值：
  - 方法值是将方法与特定实例绑定后的函数值，格式为：`instance.MethodName`
  - 方法值的第一个参数隐式绑定为该实例，调用时只需传递剩余参数。
  - 方法值可以简化函数调用，尤其是在需要多次调用同一实例的方法时。  
### 接口：
  - 接口定义了一组方法签名，任何实现了这些方法的类型都隐式实现了该接口。
  - 接口类型可以存储任何实现了该接口的值，实现多态行为。
  - 接口的零值为 `nil`，表示未指向任何具体类型。
  - 类型断言和类型转换可以用于从接口类型获取具体类型的值。
  #### 空接口：
  - 空接口 `interface{}` 不包含任何方法，表示可以存储任何类型的值。
  - 空接口常用于需要处理任意类型数据的场景，如通用容器、反射等。
  #### 类型断言：
  - 类型断言用于从接口类型获取具体类型的值，格式为：`value.(Type)`
  - 如果断言成功，返回具体类型的值；如果失败，会引发运行时错误。
  - 可以使用逗号 ok 形式来安全地进行类型断言，避免运行时错误：`value, ok := value.(Type)`
  #### 类型转换：
  - 类型转换用于将一个类型的值转换为另一个类型，格式为：`Type(value)` 
  - 类型转换需要满足类型兼容性，否则会引发编译错误。
  - 类型转换常用于基本类型之间的转换，如整数与浮点数、字符串与字节切片等。
### 嵌入：
  - 嵌入是一种将一个结构体类型嵌入到另一个结构体中的方式，实现代码复用和组合。
  - 嵌入的结构体类型的字段和方法可以直接通过外层结构体访问。
  - 嵌入可以实现类似继承的行为，但不支持方法重写。
  - 嵌入的结构体类型可以是命名类型或匿名类型。
  #### 嵌入字段访问：
  - 嵌入字段可以通过外层结构体直接访问，格式为：`outerStruct.embeddedField`
  - 如果嵌入的结构体类型有同名字段或方法，外层结构体需要通过嵌入类型名称来区分访问。
  #### 嵌入方法调用：
  - 嵌入方法可以通过外层结构体直接调用，格式为：`outerStruct.embeddedMethod()`
  - 如果嵌入的结构体类型有同名方法，外层结构体需要通过嵌入类型名称来区分调用。
### 多态实现：
  - 多态是指同一操作作用于不同类型时表现出不同的行为
  - Go 语言通过接口实现多态，不同类型只要实现了同一接口的方法，就可以赋值给该接口类型的变量。
  - 多态允许编写通用代码，提高代码的灵活性和可维护性。
  - 通过接口类型的变量，可以调用不同类型的具体实现，实现动态绑定。
  #### 多态示例：
  - 定义一个接口 `Shape`，包含方法 `Area()` 和 `Perimeter()`。
  - 定义多个结构体类型（如 `Circle`、`Rectangle`）实现该接口。
  - 创建一个函数 `PrintShapeInfo(shape Shape)`，接受接口类型参数，调用接口方法打印形状信息。
  - 通过传递不同类型的实例给 `PrintShapeInfo` 函数  ，实现多态行为。  
### 面向对象总结：
  - Go 语言通过结构体、方法、接口和嵌入实现面向对象编程的核心特性。
  - 方法和接口实现了行为的封装和多态，嵌入实现了代码复用和组合。
  - Go 语言的面向对象特性简洁且灵活，适合现代软件开发需求。
## 反射reflect
  - 反射是 Go 语言中的一种强大机制，允许在运行时检查和操作类型和值。
  - 通过反射，可以动态地获取类型信息、修改值、调用方法等。
  - 反射主要通过 `reflect` 包实现，提供了丰富的函数和类型用于操作反射对象。
  #### 反射类型和值：
  - `reflect.Type`：表示 Go 类型的接口，可以获取类型的名称、种类、字段等信息。
  - `reflect.Value`：表示 Go 值的接口，可以获取值的具体数据、修改值、调用方法等。
  #### 获取类型和值：
  - 使用 `reflect.TypeOf()` 函数获取变量的类型，返回 `reflect.Type` 对象。
  - 使用 `reflect.ValueOf()` 函数获取变量的值，返回 `reflect.Value` 对象。
  #### 修改值：
  - 使用 `reflect.Value` 的方法（如 `SetInt()`、`SetString()`）可以修改值，但前提是该值是可设置的（addressable）。
  - 修改值时需要注意类型匹配，否则会引发运行时错误。
  #### 调用方法：
  - 使用 `reflect.Value` 的 `MethodByName()` 方法获取方法，然后使用 `Call()` 方法调用该方法。
  - 调用方法时需要传递参数，参数需要是 `reflect.Value` 类型的切片。
  #### 应用场景：
  - 序列化和反序列化： 动态地将结构体转换为 JSON、XML 等格式，或从这些格式解析为结构体。
  - ORM 框架： 动态地映射数据库表与结构体，实现通用的数据访问层。
  - 测试框架： 动态地发现和运行测试用例，提高测试代码的灵活性。
  #### 性能注意事项：
  - 反射操作相对较慢，频繁使用反射可能影响性能
  - 尽量避免在性能敏感的代码路径中使用反射，或将反射结果缓存以提高效率。
## 结构体标签
  - 结构体标签是 Go 语言中用于为结构体字段添加元数据的机制。
  - 标签以字符串形式附加在结构体字段的声明后面，使用反引号包裹。
  - 标签通常用于指定序列化、验证、数据库映射等信息。
  #### 定义标签：
  - 标签的定义格式为：`FieldName Type `tagKey:"tagValue"``
  - 可以为同一字段定义多个标签，使用空格分隔。
  #### 读取标签：
  - 使用反射获取结构体字段的标签信息，通过 `reflect.Type` 的 `Field()` 方法获取字段信息，然后使用 `Tag` 字段获取标签字符串。
  - 可以使用 `Get()` 方法从标签字符串中提取特定键的值。
  #### 常见应用：
  - JSON 序列化： 使用 `json` 标签指定字段在 JSON 中的名称和选项。
  - 数据库映射： 使用 `db` 标签指定字段对应的数据库列名和属性。
  - 表单验证： 使用 `validate` 标签指定字段的验证规则。
  #### 示例：
  ```go
  type User struct {
      ID    int    `json:"id" db:"user_id"`
      Name  string `json:"name" db:"user_name" validate:"required"`
      Email string `json:"email" db:"user_email" validate:"email"`
  }
  
  // 读取标签示例
  t := reflect.TypeOf(User{})
  field, _ := t.FieldByName("Name")
  jsonTag := field.Tag.Get("json") // 获取 json 标签值
  ```
 
   